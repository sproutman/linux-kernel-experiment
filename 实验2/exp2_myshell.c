/*************************************************************************
                myshell.c  -  description
  copyright            : (C) 2012 by wangtianzhi
  Function             : 我的shell命令,练习&,<,>,|控制符控制进程并发、通信、
                         I/O 
/***************************************************************************/ 
#include <stdio.h> 
#include <unistd.h> 
#include <stdlib.h> 
#include <fcntl.h> 
#define  LS 80 
int main(){ 
    char *lineBuf,*tempBuf,*filename;  //shell 命令行处理缓冲区 
    char **argv1,**argv2;       //指向命令行可变参数串的指针 
    int fd[2];            //管道句柄 
    pid_t pid1,pid2;          //管道两端的进程号 
    int argc,status,in_arg;      //其他临时工作单元 
    int i,j,k; 
    int f_out,f_in; 
    char is_pip,is_dir,is_bkg; 

    //分配命令行缓冲区 

    //分配命令行参数缓区 

    printf("$"); //显示shell准备好提示 
    //从标准输入读一行 

    //循环处理命令行参数分割符并统计出参数个数 

    //分配参数串指针空间 

    //从命令行中分割各个参数为单独的串 
  
    //判断参数串中输入了那些 shell控制符号 

    //有管道符吗? 

           //分出管道两端命令名     

            //建立管道 

       //有I/O重定向符? 
           //分出重定向文件名     

       //父进程建立子进程 1 

       //如果为父进程 
         //有后台执行符? 
           //无,执行则等待子进程 

           //有,则立即 shell准备好提示符 
              printf("$"); 
         //有管道,管道写入文件结束符 

               close(fd[1]);//关闭管道输出 
     //如果为子进程 1 
        if(is_pip=='|'){ //有管道 
           //关闭子进程 1读管道 

           //进程1标准输出转向写管道 

           close(fd[1]); 
     } 
        if(is_dir=='>'){ //如果有输出重定向,则打开该文件 
      //以写方式打开重定向文件 
          //新文件描述符代替标准输出 
        }  
 if(is_dir=='<'){ //如果有输入重定向,则打开该文件 
      //以只读方式打开重定向文件 
          
//新文件描述符代替标准输入 

        } 

    //装入并执行子进程 1新命令 

     if(is_pip=='|'){//有管道, 
        //父进程建立子进程 2 
        //如果为父进程 
      //父进程等待子进程执行结束; 
              //如果为子进程 
            //关闭子进程 2写管道 
            //进程 2标准输出转向读管道 
            close(fd[0]); 
            //装入并执行子进程 2新命令
 
} 
/****************************END***************************************/ 
